# Equilibrium solver

`.equilibrate` contains functions to solve for the equilibrium state of a solution.

The main solver function is `solve`, but the `solvequick` and `solveloop` variants will likely be more useful in most cases.

---

## `.solve` - solve a single equilibrium

Finds the equilibrium molality of every ion in a single solution.

**Syntax:**

```python
eqstate = pz.equilibrate.solve(eqstate_guess, tots1, fixmols1, eles, allions,
    fixions, allmxs, lnkHSO4, lnkH2O, lnkMg, lnktrisH, ideal=False)
```

**Inputs:**

  * `eqstate_guess` - first guess of the equilibrium state (use `[30, 0, 0, 0]` if unsure);
  * `tots1` - total concentrations of speciating electrolytes in mol·kg<sup>−1</sup>;
  * `fixmols1` - molalities of non-speciating solutes in mol·kg<sup>−1</sup>;
  * `eles` - list of electrolyte names;
  * `allions` - list of all solute names, including those formed from `eles` and those in `fixions` below;
  * `fixions` - list of non-speciating solute names, in the same order as `fixmols1`;
  * `allmxs` - input to [matrix](../matrix) functions, generated by `pz.matrix.assemble`;
  * **lnK - TO BE CONFIRMED!**
  * `ideal` - logical indicating whether ionic strength is non-zero (`ideal=False`, default) or zero (`ideal=True`).

**Output:**

  * `eqstate` - full results of the equilibrium state solver.

See [SciPy documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html) for more details on the full contents of `eqstate`. The solver used is the BFGS algorithm. The actual equilibrium state coefficients are stored in `eqstate['x']`. These can be converted to molality values using the `eqstate2mols` function in this module.

## `.solvequick` - solve single equilibrium (usually) faster

The syntax, inputs and outputs of this function are the same as for the main `solve` function above. The difference is that `solvequick` first finds an intermediate solution for `eqstate` assuming that all activity coefficients are equal to 1 (i.e. without using the Pitzer model), and then uses this solution as the starting point to run the solver including variable activity coefficients.

It is much quicker to solve for equilibrium without the Pitzer model than with it. In both cases, equilibrium is found faster if the initial conditions (i.e. `eqstate_guess`) are closer to their final solved values.

So, by not using the Pitzer model, the intermediate solution is reached relatively quickly. It provides a new first guess of the `eqstate` that will often be closer to the true solution than the original, user-selected first guess. This means that the slower solver, with Pitzer-modelled variable activity coefficients, can also reach its target more quickly.

However, this approach is only faster if the intermediate solution is actually closer to the final value than the final result.

## `.solveloop` - solve a series of equilibria

This allows you to solve a series of equilibria (e.g. multiple rows imported from a CSV file using `io.gettots`) using a single function.

The first equilibrium in the loop is solved using `solvequick`. However, all subsequent functions are solved using `solve` - but with the `eqstate` result from the previous equilibrium used as the first guess. Therefore the more similar the solution composition and conditions (temperature and pressure) from one equilibrium to the next, the faster the loop will run. If the solutions are all very different from each other, it may be faster to use `solvequick` for each one separately instead.

**Syntax:**

```python
allmols, allions, eqstates = solveloop(eqstate_guess, tots, fixmols,
    eles, fixions, tempK, pres, prmlib=libraries.Seawater)
```

**Inputs:**

  * `eqstate_guess` - first guess of the equilibrium state for the first equilibrium (use `[30, 0, 0, 0]` if unsure);
  * `tots` - total concentrations of speciating electrolytes in mol·kg<sup>−1</sup>;
  * `fixmols` - molalities of non-speciating solutes in mol·kg<sup>−1</sup>;
  * `eles` - array of electrolyte names;
  * `fixions` - array of non-speciating solute names, in the same order as the rows in `fixmols`;
  * `tempK` - array of the temperature for each equilibrium in K;
  * `pres` - array of the pressure for each equilibrium in dbar;
  * `prmlib` - the [parameter library](../libraries) to use (defaults to `Seawater`).

**Outputs:**

  * `allmols` - matrix of all molalities at equilibrium in mol·kg<sup>−1</sup>, ready to use with Pytzer's [model](../model) functions;
  * `allions` - array of all ions, corresponding to the rows of `allmols`;
  * `eqstates` - matrix of solved `eqstate` for each equilibrium.

---

## `.eqstate2mols` - convert `eqstate` into molalities

The equilibrium solvers return a series of numbers in a format that is not very useful. This function converts those numbers into molality values. If you use `solveloop`, this step is already done for you.

**Syntax:**

```python
allmols, allions = pz.equilibrate.eqstate2mols(eqstate,
    tots1, fixmols1, eles, fixions)
```

**Inputs:**

  * `eqstate` - numerical results from an equilibrium state solve (i.e. `eqstate['x']`);
  * `tots1` - total concentrations of speciating electrolytes in mol·kg<sup>−1</sup>;
  * `fixmols1` - molalities of non-speciating solutes in mol·kg<sup>−1</sup>;
  * `eles` - list of electrolyte names;
  * `fixions` - list of non-speciating solute names, in the same order as `fixmols1`.

**Outputs:**

  * `allmols` - matrix of all molalities at equilibrium in mol·kg<sup>−1</sup>, ready to use with Pytzer's [model](../model) functions;
  * `allions` - array of all ions, corresponding to the rows of `allmols`.
